<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>For the Purely Lazy</title>

    <!-- reveal js -->
    <link rel="stylesheet" href="../css/reveal.css">
    
    <link rel="stylesheet" href="../css/theme/serif.css" id="theme">
    

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" type="text/css" href="../css/highlighting.css" />

    <!--[if lt IE 9]>
    <script src="../lib/js/html5shiv.js"></script>
    <![endif]-->

  </head>

  <body>
    <div class="reveal">
      <div class="slides">
<section><section id="for-the-purely-lazy" class="titleslide slide level1"><h1>For the Purely Lazy</h1></section><section id="the-low-down" class="slide level2">
<h2>The Low Down</h2>
<ul>
<li>Looking at Lazy Evaluation in the purely functional language Haskell.</li>
<li>All about the lazy, purity just along for the ride.</li>
<li>Wat is Lazy Evaluation?</li>
<li>What is it good for?</li>
<li>What are the gotchas?</li>
</ul>
</section></section>
<section><section id="evaluation-strategies" class="titleslide slide level1"><h1>Evaluation strategies</h1></section><section id="eager-or-lazy" class="slide level2">
<h2>Eager or Lazy</h2>
<ul>
<li><p>In Haskell like languages evaluation is reducing expressions to their simplest form.<br />
<span style="color:lightblue"><code>(5 + 4 - 2) * (5 + 4 - 2) ⇒ 49</code></span></p></li>
<li><p>Two options when expression includes function application.<br />
<span style="color:lightblue"><code>square (5 + 4 - 2) ⇒ 49</code></span></p>
<ul>
<li><p><span style="color:red"> Reduce arguments first (<em>Innermost reduction / Eager Evaluation</em>)</span><br />
<span style="color:firebrick"> <code>square (5 + 4 - 2) ⇒ square(7) ⇒ 7 * 7 ⇒ 49</code> </span></p></li>
<li><p><span style="color:limegreen"> Apply function first (<em>Outermost reduction / Lazy Evaluation</em>)</span><br />
<span style="color:olivedrab"> <code>square (5 + 4 - 2) ⇒ (5 + 4 - 2) * (5 + 4 - 2) ⇒ 7 * 7 ⇒ 49</code> </span></p></li>
</ul></li>
<li>Final answer == expression in normal form<br />
<span style="color:lightblue"><code>49</code></span> is the normal form of <span style="color:lightblue"><code>square (5 + 4 - 2)</code></span></li>
<li>Eager also called strict.</li>
<li>Lazy also called non-strict (sort of)
<ul>
<li>Lazy is non-strict but non-strict is not necessarily Lazy.</li>
<li>Haskell requires non-strictness</li>
<li>Most implementations are Lazy</li>
</ul></li>
</ul>
<aside class="notes">
<p>Inner most reduction / outer most reduction from [Thinking Functionally with Haskell][] page 27.</p>
</aside>
</section><section id="lazy-is-a-bit-more-involved" class="slide level2">
<h2>Lazy is a bit more involved</h2>
<div style="width: 50%;float: left;">
<ul>
<li>Outermost reduction</li>
<li>Only evaluate as needed
<ul>
<li>Not to normal form</li>
<li>To head normal form / weak head normal form</li>
<li>Outer most constructor</li>
</ul></li>
<li>Shares sub expressions when expanding</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">square (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">4</span>)
<span class="ot">⇒</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">4</span> <span class="kw">in</span> square x
<span class="ot">⇒</span> x <span class="fu">*</span> x
<span class="ot">⇒</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">7</span> <span class="kw">in</span> x <span class="fu">*</span> x
<span class="ot">⇒</span> <span class="dv">7</span><span class="fu">*</span><span class="dv">7</span>
<span class="ot">⇒</span> <span class="dv">49</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dv">5</span>,square (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">4</span>))
<span class="ot">⇒</span> <span class="kw">let</span> a <span class="fu">=</span> <span class="dv">5</span>, b <span class="fu">=</span> square (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">4</span>) <span class="kw">in</span> (a,b)</code></pre></div>
</div>
<div style="width: 50%;float: right;">
<img src="../media/Lazy_Eval_Sharing_and_Head_Normal.svg" alt="Lazy evaluation showing sharing and evaluating to head normal form" />
<div>


</section><section id="whats-the-difference" class="slide level2">
<h2>Whats the difference</h2>
<div style="width: 50%;float: left;">
<p>Given</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fst (a, b) <span class="fu">=</span> a
fst (<span class="dv">0</span>, square (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">4</span>)) </code></pre></div>
<p>Eager</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fst (<span class="dv">0</span>, square (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">4</span>)) 
<span class="ot">⇒</span> fst (<span class="dv">0</span>, square <span class="dv">9</span>) 
<span class="ot">⇒</span> fst (<span class="dv">0</span>, <span class="dv">9</span> <span class="fu">*</span> <span class="dv">9</span>)
<span class="ot">⇒</span> <span class="dv">0</span></code></pre></div>
<p>Lazy</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fst (<span class="dv">0</span>, square (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">4</span>)) 
<span class="ot">⇒</span> <span class="kw">let</span> a <span class="fu">=</span> <span class="dv">0</span>, b <span class="fu">=</span> square (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">4</span>) <span class="kw">in</span> fst (a, b) 
<span class="ot">⇒</span> a
<span class="ot">⇒</span> <span class="dv">0</span></code></pre></div>
<p>Lazy never evaluated <span style="color:lightblue"><code>square (5 + 4)</code></span> where eager did.</p>
</div>
<div style="width: 50%;float: right;">
<figure>
<img src="../media/Lazy_vs_Eager.svg" alt="Lazy vs Eager evaluation" /><figcaption>Lazy vs Eager evaluation</figcaption>
</figure>
</div>
</section><section class="slide level2">

<div style="height: 5%;float: top;">
<p>Given</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fst (<span class="dv">0</span>, ⊥) </code></pre></div>
</div>
<div style="height: 95%;float: bottom;">
<div style="width: 50%;float: left;">
<p>Eager</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fst (<span class="dv">0</span>, ⊥) 
<span class="ot">⇒</span> fst ⊥
<span class="ot">⇒</span> ⊥</code></pre></div>
</div>
<div style="width: 50%;float: right;">
<p>Lazy</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fst (<span class="dv">0</span>, ⊥) 
<span class="ot">⇒</span> <span class="kw">let</span> a <span class="fu">=</span> <span class="dv">0</span>, b <span class="fu">=</span> ⊥ <span class="kw">in</span> fst (a, b) 
<span class="ot">⇒</span> a
<span class="ot">⇒</span> <span class="dv">0</span></code></pre></div>
</div>
</div>
<div style="height: 5%;float: bottom;">
<ul>
<li>In the presence of bottom (⊥, undefined / non termination)</li>
<li>Lazy evaluation can still return a result</li>
<li>Lazy version never evaluated the ⊥ argument.</li>
</ul>
</div>
</section><section id="lazy-always-best-well-no." class="slide level2">
<h2>Lazy always best! Well no.</h2>
<div style="width: 30%;float: left;">
<ul>
<li>Lazy evaluation has a bookkeeping overhead</li>
<li>Unevaluated expression builds up in memory</li>
<li>Eager is not always better than Lazy</li>
<li>Lazy is not always better than Eager</li>
<li>Just a note, technically primitive operations in GHC are not lazy.</li>
</ul>
</div>
<div style="width: 70%;float: right;">
<figure>
<img src="../media/Lazy_vs_Eager_Cost.svg" alt="The cost of lazy evaluation" /><figcaption>The cost of lazy evaluation</figcaption>
</figure>
</div>
</section></section>
<section><section id="the-good-the-bad-and-the-smugly" class="titleslide slide level1"><h1>The Good, The Bad and The Smugly</h1></section><section id="the-good-and-bad" class="slide level2">
<h2>The Good and Bad</h2>
<div style="width: 50%;float: left;">
<h3>
Pros
</h3>
<ul>
<li>More efficient ?
<ul>
<li>This is a red herring.</li>
<li>It could be or it couldn’t.</li>
</ul></li>
<li>Modularity!
<ul>
<li>This is the real reason</li>
<li>John Hughes - <a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf" title="Why Functional Programming Matters">Why Functional Programming Matters</a></li>
<li>Glue allowing composition of functional programs</li>
</ul></li>
<li>Efficient tricks for pure languages.
<ul>
<li>Again ? Contradiction ? Nope.</li>
<li>Memoization preserving purity and abstraction.</li>
<li>Caching preserving purity and abstraction.</li>
</ul></li>
</ul>
</div>
<div style="width: 50%;float: right;">
<h3>
Cons
</h3>
<ul>
<li>Difficult to reason about time and space usage.
<ul>
<li>Time ? Not sold.
<ul>
<li>Lazy O(n) &lt;= Eager O(n)</li>
<li>When is the cost? Latency is a concern.</li>
</ul></li>
<li>Space ?
<ul>
<li>Unfortunately yes.</li>
<li>The dreaded space leak.</li>
</ul></li>
</ul></li>
<li>Parallel unfriendly
<ul>
<li>Doing work in parallel means doing the work in parallel.</li>
<li>Have to force work to be done.</li>
<li>Only an issue if you believe in automagic parallelization.</li>
<li>See <a href="httP://http://community.haskell.org/~simonmar/pcph/" title="Parallel and Concurrent Programming in Haskell: Techniques for Multicore and Multithreaded Programming">Parallel and Concurrent Programming in Haskell</a></li>
</ul></li>
</ul>
</div>
<aside class="notes">

</aside>
</section><section id="so-dont-be-smug" class="slide level2">
<h2>So Don’t be Smug</h2>
<ul>
<li>Laziness is not a silver bullet.</li>
<li>Laziness is not a scarlet letter.</li>
<li>Most eager languages have lazy constructs.</li>
<li>Most lazy languages have eager constructs.</li>
</ul>
</section></section>
<section><section id="modularity" class="titleslide slide level1"><h1>Modularity</h1></section><section id="lazy-aids-composition" class="slide level2">
<h2>Lazy Aids Composition</h2>
<ul>
<li>From Why <a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf" title="Why Functional Programming Matters">Functional Programming Matters</a></li>
<li>Can structured whole programs as function composition</li>
<li><span style="color: lightblue"><code>(f . g) input == f (g input)</code></span></li>
<li><span style="color: lightblue"><code>g</code></span> only consumes <span style="color: lightblue"><code>input</code></span> as <span style="color: lightblue"><code>f</code></span> needs it.</li>
<li><span style="color: lightblue"><code>f</code></span> knows nothing of <span style="color: lightblue"><code>g</code></span></li>
<li><span style="color: lightblue"><code>g</code></span> knows nothing of <span style="color: lightblue"><code>f</code></span></li>
<li>When <span style="color: lightblue"><code>f</code></span> terminates <span style="color: lightblue"><code>g</code></span> terminates</li>
<li>Allows termination conditions to be separated from loop bodies.</li>
<li>Can modularise as generators and selectors.</li>
</ul>
</section><section id="lazy-composition-sqrt" class="slide level2">
<h2>Lazy Composition Sqrt</h2>
<div style="height: 50%; float: top">
<ul>
<li>Example from Why <a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf" title="Why Functional Programming Matters">Functional Programming Matters</a></li>
<li>Newton-Raphson to calculate square root approximation.</li>
<li>One function generates sequence of approximations.</li>
<li>Two options to chose when approximation is good enough.
<ul>
<li>Don’t care approximations to what.</li>
</ul></li>
<li>Can to give different square root approximations.</li>
<li>Paper expands on examples of Laziness aiding composition.</li>
</ul>
</div>
<div style="height: 50%; float: bottom">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Generate a sqrt sequence of operations using Newton-Raphson</span>
nextSqrtApprox n x <span class="fu">=</span> (x <span class="fu">+</span> n<span class="fu">/</span>x) <span class="fu">/</span> <span class="dv">2</span>
<span class="co">-- iterate f x == [x, f x, f (f x), ...]</span>
sqrtApprox n <span class="fu">=</span> iterate (nextSqrtApprox n) (n<span class="fu">/</span><span class="dv">2</span>)
<span class="co">-- element where the difference with previous is below threshold</span>
within eps (a<span class="fu">:</span>b<span class="fu">:</span>bs) <span class="fu">|</span> abs(a<span class="fu">-</span>b) <span class="fu">&lt;=</span> eps <span class="fu">=</span> b
                    <span class="fu">|</span> otherwise <span class="fu">=</span> within eps (b<span class="fu">:</span>bs)
<span class="co">-- Calculate approximate sqrt using within</span>
withinSqrt eps n <span class="fu">=</span> within eps (sqrtApprox n)
<span class="co">-- element where ratio with previous is close to 1</span>
relative eps (a<span class="fu">:</span>b<span class="fu">:</span>bs) <span class="fu">|</span> abs(a<span class="fu">-</span>b) <span class="fu">&lt;=</span> eps <span class="fu">*</span> abs b <span class="fu">=</span> b
                      <span class="fu">|</span> otherwise <span class="fu">=</span> relative eps (b<span class="fu">:</span>bs)
<span class="co">-- Calculate approximate sqrt using relative</span>
relativeSqrt eps n <span class="fu">=</span> within eps (sqrtApprox n)</code></pre></div>
</div>
</section><section id="caveats-about-lazy-composition" class="slide level2">
<h2>Caveats about Lazy Composition</h2>
<ul>
<li>When using Lazy IO
<ul>
<li>Promptness of resource finalization is a problem</li>
</ul></li>
<li>Use libraries libraries like
<ul>
<li><a href="https://hackage.haskell.org/package/conduit" title="Conduit">Conduit</a></li>
<li><a href="https://wiki.haskell.org/Memoization" title="Haskell Wiki Memoization">Pipes</a></li>
</ul></li>
</ul>
</section></section>
<section><section id="lazy-tricks" class="titleslide slide level1"><h1>Lazy Tricks</h1></section><section id="memoization" class="slide level2">
<h2>Memoization</h2>
<div style="width: 30%; float: left">
<ul>
<li>Use Laziness to incrementally build the list of all Fibonacci numbers.</li>
<li>The list refers to itself to reuse calculations.</li>
<li>The list is in constant applicative form (CAF) so is memoized</li>
<li>See <a href="https://wiki.haskell.org/Memoization" title="Haskell Wiki Memoization">Haskell wiki</a> for more tricks using infinite data structures to memoize functions.</li>
</ul>
</div>
<div style="width: 70%; float: right">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fib_list ::</span> [<span class="dt">Integer</span>]
fib_list <span class="fu">=</span> <span class="dv">0</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>[n2 <span class="fu">+</span> n1<span class="fu">|</span> (n2, n1) <span class="ot">&lt;-</span> 
                    zip (drop <span class="dv">2</span> fib_list) (drop <span class="dv">3</span> fib_list)]
<span class="ot">fib_best ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fib_best n <span class="fu">=</span> fib_list <span class="fu">!!</span> n</code></pre></div>
<p>GHCi with timing</p>
<pre><code>*Main&gt; 5 &lt; fib_best 100000
True
(0.86 secs, 449258648 bytes)
*Main&gt; 5 &lt; fib_best 100001
True
(0.02 secs, 0 bytes)
*Main&gt; </code></pre>
</div>
</section><section id="caching" class="slide level2">
<h2>Caching</h2>
<ul>
<li>So you have some data/results and some expensive queries against it.</li>
<li>You want to perform the queries only when they are needed.</li>
<li>You want to perform the queries only once.</li>
<li>You must preserve purity.</li>
<li>What do you do?</li>
<li>Perform the queries and store in the data structure.</li>
<li>Laziness means they will only be evaluated once and only when needed.</li>
</ul>
</section><section class="slide level2">

<ul>
<li>Canned example using really expensive fib.</li>
<li><code>Fibber</code> is some <code>Num</code> type you can do math on.</li>
<li>You can ask it for the resultant value of the Fibonacci number.</li>
<li>You wont export the constructor.</li>
</ul>
<div style="width: 60%; float: left;">
<div class="sourceCode"><pre class="sourceCode haskell stretch"><code class="sourceCode haskell"><span class="ot">fib_worst ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fib_worst <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib_worst <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib_worst <span class="dv">2</span> <span class="fu">=</span> <span class="dv">1</span>
fib_worst n <span class="fu">=</span> fib_worst(n<span class="fu">-</span><span class="dv">2</span>) <span class="fu">+</span> fib_worst(n<span class="fu">-</span><span class="dv">1</span>)

<span class="kw">data</span> <span class="dt">Fibber</span> <span class="fu">=</span> <span class="dt">Fibber</span>{<span class="ot">fibNum ::</span> <span class="dt">Int</span>,<span class="ot"> fibValue ::</span> <span class="dt">Integer</span>}
<span class="ot">makeFibber ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fibber</span>
makeFibber a <span class="fu">=</span> <span class="dt">Fibber</span> a (fib_worst a)
<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Fibber</span> <span class="kw">where</span> a <span class="fu">==</span> b <span class="fu">=</span> fibNum a <span class="fu">==</span> fibNum b
<span class="kw">instance</span> <span class="dt">Ord</span> <span class="dt">Fibber</span> <span class="kw">where</span> a <span class="fu">&lt;=</span> b <span class="fu">=</span> fibNum a <span class="fu">&lt;=</span> fibNum b
<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Fibber</span> <span class="kw">where</span> show a <span class="fu">=</span> show <span class="fu">.</span> fibNum <span class="fu">$</span> a
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Fibber</span> <span class="kw">where</span>
    a <span class="fu">+</span> b <span class="fu">=</span> makeFibber (fibNum a <span class="fu">+</span> fibNum b)
    a <span class="fu">*</span> b <span class="fu">=</span> makeFibber (fibNum a <span class="fu">*</span> fibNum b)
    abs <span class="fu">=</span> makeFibber <span class="fu">.</span> abs <span class="fu">.</span> fibNum
    signum <span class="fu">=</span> makeFibber <span class="fu">.</span> signum <span class="fu">.</span> fibNum
    fromInteger <span class="fu">=</span> makeFibber <span class="fu">.</span> fromInteger
    negate <span class="fu">=</span> makeFibber <span class="fu">.</span> negate <span class="fu">.</span> fibNum</code></pre></div>
</div>
<div style="width: 40%; float: right;">
<p>GHCi</p>
<pre><code>*Main&gt; let fibber30 = makeFibber 30
(0.00 secs, 0 bytes)
*Main&gt; let fibber25 = makeFibber 25
(0.00 secs, 0 bytes)
*Main&gt; fibValue (fibber30 - fibber25)
5
(0.00 secs, 0 bytes)
*Main&gt; fibValue fibber30
832040
(1.22 secs, 127472744 bytes)
*Main&gt; fibValue fibber30
832040
(0.00 secs, 0 bytes)
*Main&gt; fibValue fibber25
75025
(0.11 secs, 10684624 bytes)
*Main&gt; </code></pre>
</div>
</section></section>
<section><section id="time-and-space" class="titleslide slide level1"><h1>Time and Space</h1></section><section id="times-up" class="slide level2">
<h2>Times up</h2>
<ul>
<li>Algorithmic complexity of Lazy evaluation is never more than Eager.</li>
<li>Consider Eager behaviour for upper bound.</li>
<li>Real issue - work might be delayed.</li>
<li>Delayed work is real issue for parallelism.</li>
<li>Can always force work using <a href="http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#v:seq" title="Base library seq">seq</a> and <a href="http://hackage.haskell.org/package/deepseq-1.4.0.0/docs/Control-DeepSeq.html" title="DeepSeq library">deepseq</a> and <a href="http://hackage.haskell.org/package/deepseq-1.4.0.0/docs/Control-DeepSeq.html" title="DeepSeq library">force</a></li>
<li>See <a href="httP://http://community.haskell.org/~simonmar/pcph/" title="Parallel and Concurrent Programming in Haskell: Techniques for Multicore and Multithreaded Programming">Parallel and Concurrent Programming in Haskell</a></li>
</ul>
</section><section id="space-leaks" class="slide level2">
<h2>Space Leaks</h2>
<ul>
<li>Space Leak - program / expression uses more memory than required.
<ul>
<li>Memory is eventually released</li>
<li>You think it will run in constant memory but it doesn’t</li>
<li>Building up unevaluated thunks.</li>
<li>Unnecessarily keeping reference to data alive.</li>
</ul></li>
<li>Memory leak - program allocates memory that is never reclaimed.</li>
<li>Pure Haskell code can only be able to Space Leak (no Memory Leak).</li>
<li>Most other Haskell code should only be able to Space Leak (mostly no Memory Leak).</li>
</ul>
</section><section id="examples-from-leaking-space" class="slide level2">
<h2>Examples from “Leaking Space”</h2>
<ul>
<li><p>Some space leak examples from [Leaking Space - Eliminating memory hogs][8]</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">xs <span class="fu">=</span> delete <span class="st">&quot;dead&quot;</span> [<span class="st">&quot;alive&quot;</span>, <span class="st">&quot;dead&quot;</span>]</code></pre></div></li>
<li>Lazy evaluation will keep <code>dead</code> alive until evaluation of <code>xs</code> is forced.</li>
<li><p>One form of space leak results from adding to and removing from lists but never evaluating (to reduce).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">xs <span class="fu">=</span> <span class="kw">let</span> xs' <span class="fu">=</span> delete <span class="st">&quot;dead&quot;</span> [<span class="st">&quot;alive&quot;</span>, <span class="st">&quot;dead&quot;</span>] <span class="kw">in</span> xs' <span class="ot">`seq`</span> xs'</code></pre></div></li>
<li>Why not always strict/eager.
<ul>
<li>Composition.</li>
<li>Composing strictly requires arguments to be evaluated fully.</li>
<li><code>sum [1..n]</code> will consume O(n) space when evaluated strictly.</li>
<li><code>sum [1..n]</code> <strong>should</strong> consume O(1) space when evaluated lazily (implementation).</li>
<li>Usually easier to introduce strictness when lazy than laziness when strict.</li>
</ul></li>
</ul>
</section><section class="slide level2">

<ul>
<li>This definition is O(n) space.</li>
<li>List is not actually kept in memory</li>
<li><p>Accumulates <code>(+)</code> operations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum1 (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sum1 xs 
sum1 [] <span class="fu">=</span> <span class="dv">0</span></code></pre></div></li>
<li>This definition is O(n) space.</li>
<li><p>Also accumulates <code>(+)</code> operations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum2 xs <span class="fu">=</span> sum2’ <span class="dv">0</span> xs 
   <span class="kw">where</span> 
   sum2’ a (x<span class="fu">:</span>xs) <span class="fu">=</span> sum2’ (a<span class="fu">+</span>x) xs 
   sum2’ a [] <span class="fu">=</span> a</code></pre></div></li>
<li><p>This definition is O(1) space.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum3 xs <span class="fu">=</span> sum3’ <span class="dv">0</span> xs 
   <span class="kw">where</span> 
   sum3’ <span class="fu">!</span>a (x<span class="fu">:</span>xs) <span class="fu">=</span> sum3’ (a<span class="fu">+</span>x) xs 
   sum3’ <span class="fu">!</span>a [] <span class="fu">=</span> a</code></pre></div></li>
<li>With optimizations in GHC <code>sum2</code> may be transformed into <code>sum3</code> during strictness analysis.</li>
<li><p>The article has more examples of space leaks. [8]: http://queue.acm.org/detail.cfm?id=2538488 (Leaking Space - Eliminating memory hogs: By Neil Mitchell)</p></li>
</ul>
</section><section id="when-strictness-can-make-things-slow" class="slide level2">
<h2>When Strictness can make things slow</h2>
<div style="float: top;">
<ul>
<li>Maybe one should just through strictness in everywhere</li>
<li>Something I did not know. Pattern matches are strict.</li>
<li>Example from <a href="https://wiki.haskell.org/Lazy_pattern_match" title="Haskell Wiki Lazy Pattern Matching">Haskell Wiki</a></li>
<li>Strict pattern match forces all recursive calls to splitAt</li>
</ul>
</div>
<div style="float: bottom;">
<div style="width: 50%; float: left;">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Strict</span>
splitAt_sp n xs <span class="fu">=</span> (<span class="st">&quot;splitAt_lp &quot;</span> <span class="fu">++</span> show n) <span class="fu">$</span>
    <span class="kw">if</span> n<span class="fu">&lt;=</span><span class="dv">0</span>
        <span class="kw">then</span> ([], xs)
        <span class="kw">else</span>
            <span class="kw">case</span> xs <span class="kw">of</span>
                [] <span class="ot">-&gt;</span> ([], [])
                y<span class="fu">:</span>ys <span class="ot">-&gt;</span>
                    <span class="kw">case</span> splitAt_lp' (n<span class="fu">-</span><span class="dv">1</span>) ys <span class="kw">of</span>
                        <span class="co">-- pattern match is strict</span>
                        (prefix, suffix) <span class="ot">-&gt;</span> (y <span class="fu">:</span> prefix, suffix)</code></pre></div>
</div>
<div style="width: 50%; float: right;">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Lazy</span>
splitAt_lp n xs <span class="fu">=</span> (<span class="st">&quot;splitAt_lp &quot;</span> <span class="fu">++</span> show n) <span class="fu">$</span>
    <span class="kw">if</span> n<span class="fu">&lt;=</span><span class="dv">0</span>
        <span class="kw">then</span> ([], xs)
        <span class="kw">else</span>
            <span class="kw">case</span> xs <span class="kw">of</span>
                [] <span class="ot">-&gt;</span> ([], [])
                y<span class="fu">:</span>ys <span class="ot">-&gt;</span>
                    <span class="kw">case</span> splitAt_lp' (n<span class="fu">-</span><span class="dv">1</span>) ys <span class="kw">of</span>
                        <span class="co">-- pattern match is lazy</span>
                        <span class="fu">~</span>(prefix, suffix) <span class="ot">-&gt;</span> (y <span class="fu">:</span> prefix, suffix)</code></pre></div>
</div>
</div>
<div style="float: bottom;">
<p>GHCi</p>
<pre><code>*Main&gt; sum . take 5 . fst . splitAt_sp 10000000 $ repeat 1
5
(20.78 secs, 3642437376 bytes)
*Main&gt; sum . take 5 . fst . splitAt_lp 10000000 $ repeat 1
5
(0.00 secs, 0 bytes)</code></pre>
</div>
</section><section id="what-to-do-with-thorny-space-leaks" class="slide level2">
<h2>What to do with thorny space leaks</h2>
<ul>
<li>Pinpoint leaks using GHC’s profiling tools.</li>
<li>For some domains libraries exist that eliminate large classes of space leaks by design
<ul>
<li>Streaming libraries like
<ul>
<li><a href="https://hackage.haskell.org/package/conduit" title="Conduit">Conduit</a></li>
<li><a href="https://wiki.haskell.org/Memoization" title="Haskell Wiki Memoization">Pipes</a></li>
</ul></li>
<li>FRP Libraries like
<ul>
<li><a href="https://hackage.haskell.org/package/netwire" title="Netwire">Netwire</a></li>
</ul></li>
</ul></li>
</ul>
</section></section>
<section><section id="further-reading" class="titleslide slide level1"><h1>Further reading</h1></section></section>
      </div>
    </div>
    

    <script src="../lib/js/head.min.js"></script>
    <script src="../js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // // The "normal" size of the presentation, aspect ratio will be preserved
        // // when the presentation is scaled to fit different resolutions. Can be
        // // specified using percentage units.
        // width: 960,
        // height: 700,

        // // Factor of the display size that should remain empty around the content
        // margin: 0.0,

        // // Bounds for smallest/largest possible scale to apply to content
        // minScale: 0.1,
        // maxScale: 2.5,

        // with sizing
        width: 1000, height: 1220, margin: 0.1, minScale: 0.1, maxScale: 3,

        // no sizing
        // width: "100%", height: "100%", margin: 0, minScale: 1, maxScale: 1,

        // Display controls in the bottom right corner
        
        controls: true,
        


        // Display a presentation progress bar
        
        progress: true,
        

        // Set default timing of 2 minutes per slide
        defaultTiming: 120,

        // Display the page number of the current slide
        slideNumber: false,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: true,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autolaying embedded media (video/audio/iframe)
        // - null: Media will only autoplay if data-autoplay is present
        // - true: All media will autoplay, regardless of individual setting
        // - false: No media will autoplay, regardless of individual setting
        autoPlayMedia: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: Reveal.navigateNext,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

        // The display mode that will be used to show slides
        display: 'block',

        // Optional reveal.js plugins
        dependencies: [
          { src: '../lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
