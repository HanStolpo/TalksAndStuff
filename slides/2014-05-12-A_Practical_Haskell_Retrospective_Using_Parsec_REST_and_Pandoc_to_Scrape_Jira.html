<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="../css/reveal.css">
		<link rel="stylesheet" href="../css/theme/moon.css" id="theme">
		<link rel="stylesheet" type="text/css" href="../css/highlighting.css" />

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="../lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../css/print/pdf.css' : '../css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="../lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
<section><section id="introduction" class="titleslide slide level1"><h1>Introduction</h1></section><section id="me-and-the-talk" class="slide level2">
<h1>Me and the talk</h1>
<ul>
<li>Post related to slides <a href="http://hanstolpo.github.io/TalksAndStuff/posts/2014-05-12-A_Practical_Haskell_Retrospective_Using_Parsec_REST_and_Pandoc_to_Scrape_Jira.html">http://hanstolpo.github.io/TalksAndStuff/posts/2014-05-12-A_Practical_Haskell_Retrospective_Using_Parsec_REST_and_Pandoc_to_Scrape_Jira.html</a></li>
<li>For links see the post</li>
<li>Retrospective about internal “tool” to generate specification documents from Jira</li>
<li>The first practical Haskell code I wrote</li>
<li>I come from an imperitive background
<ul>
<li>10 years advanced C++ and some Lua</li>
<li>Essentially game engine development</li>
<li>No advanced mathematics background</li>
<li>Zero exposure to functional languages</li>
</ul></li>
<li>Haskell is not that hard you just have to get used to it</li>
</ul>
</section><section id="background" class="slide level2">
<h1>Background</h1>
<ul>
<li>We make training simulators</li>
<li>Our issue tracking system is Jira</li>
<li>Some clients require official, configured, OKed hardcopy documents</li>
<li>We want one place to track and define our requirements</li>
<li>We want to generate the documents from Jira</li>
<li>Didn’t find a tool to exactly meet our needs</li>
<li>Lets write one :)</li>
</ul>
</section><section id="background-1" class="slide level2">
<h1>Background</h1>
<ul>
<li>Had just read
<ul>
<li><strong>Learn You a Haskell for Great Good!</strong></li>
<li><strong>Real World Haskell</strong></li>
</ul></li>
<li>Opportunity to <em>actually</em> learn Haskell by writing a tool</li>
<li>Had scouted the lay of the land
<ul>
<li>Jira exposed RESTful HTTP interface</li>
<li>HTTP-Conduit like CURL in Haskell (Talk to Jira)</li>
<li>All powerful Pandoc (any format to any format, sortof)</li>
<li>Parsers are easy just use Parsec (lots of tears)</li>
</ul></li>
</ul>
</section><section id="what-the-tool-had-to-do" class="slide level2">
<h1>What the tool had to do</h1>
<ul>
<li>Issues organized hierarchically using Structure plug-in</li>
<li>Hierarchy defines document outline</li>
<li>Heading: issue key with issue summary</li>
<li>Content: issue description</li>
<li>Talk to Jira over HTTP</li>
<li>Parse descriptions and generate Pandoc AST</li>
<li>Use Pandoc to generate MS Word document</li>
<li>Only had to glue libraries together
<ul>
<li>Except for the parser</li>
</ul></li>
</ul>
</section></section>
<section><section id="talking-to-jira" class="titleslide slide level1"><h1>Talking to Jira</h1></section><section id="jiras-restlike-interface" class="slide level2">
<h1>Jira’s RESTlike Interface</h1>
<ul>
<li>Access Jira over HTTP using the Jira REST APIs
<ul>
<li>Is the API 100% RESTful? I have no clue.</li>
</ul></li>
<li>REST = representational state transfer
<ul>
<li>architectural style described by Roy Fielding in 2000</li>
<li>REST internet buzz word
<ul>
<li>A lot of APIs claim to be RESTful but technically aren’t</li>
<li>Its not SOAP so its REST</li>
</ul></li>
</ul></li>
<li>Let’s not offend anyone and call it RESTlike</li>
</ul>
</section><section id="restlike---incomplete-incorrect-over-simplified" class="slide level2">
<h1>RESTlike - incomplete, incorrect, over simplified</h1>
<ul>
<li>It is client server based.</li>
<li>Communication is stateless.
<ul>
<li>State held on client side</li>
<li>Every request contains all the data</li>
<li>Messages should be self describing</li>
</ul></li>
<li>Interact with resources</li>
<li>Resources identifiable by URI
<ul>
<li>URL <code>http://blah.com/blahs/132</code></li>
<li>Protocol is <code>HTTP</code></li>
<li>Host is <code>blah.com</code></li>
<li>Path to the resource <code>/blahs/132</code></li>
</ul></li>
</ul>
</section><section id="restlike---incomplete-incorrect-over-simplified-1" class="slide level2">
<h1>RESTlike - incomplete, incorrect, over simplified</h1>
<ul>
<li>One resource multiple representation (e.g. HTML, XML, JSON, etc)</li>
<li>Interface constrained to the standard methods of the protocol.
<ul>
<li>HTTP you use GET, POST, PUT and DELETE.</li>
<li>GET query and safe</li>
<li>DELETE removes and is idempotent</li>
<li>PUT updates/creates and is idempotent</li>
<li>POST adds and is a non-idempotent (anything goes).</li>
</ul></li>
<li>There is actually lots more.</li>
</ul>
</section><section id="restlike---incomplete-incorrect-over-simplified-2" class="slide level2">
<h1>RESTlike - incomplete, incorrect, over simplified</h1>
<p>Example matrix from Wikipedia</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 21%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Resource</th>
<th style="text-align: left;">GET</th>
<th style="text-align: left;">PUT</th>
<th style="text-align: left;">POST</th>
<th style="text-align: left;">DELETE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><p>Collection</p>
<p>http://eg.com/resources</p></td>
<td style="text-align: left;"><p>List the URIs and other details of elements.</p></td>
<td style="text-align: left;"><p>Replace the entire collection.</p></td>
<td style="text-align: left;"><p>Add a new entry to the collection. URI is assigned automatically.</p></td>
<td style="text-align: left;"><p>Delete the entire collection.</p></td>
</tr>
<tr class="even">
<td style="text-align: left;"><p>Element</p>
<p>http://eg.com/resources/item17</p></td>
<td style="text-align: left;"><p>Retrieve addressed element expressed in appropriate media type</p></td>
<td style="text-align: left;"><p>Replace element or if it does not exist the create it.</p></td>
<td style="text-align: left;"><p>Not generally used. Treat element as collection and create new entry</p></td>
<td style="text-align: left;"><p>Delete the item from the collection.</p></td>
</tr>
</tbody>
</table>
</section><section id="http-conduit-example" class="slide level2">
<h1>HTTP-Conduit example</h1>
<pre class="sourceCode stretch Haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Network.HTTP.Conduit</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Types.Header</span>
<span class="kw">import </span><span class="dt">Network.Connection</span> (<span class="dt">TLSSettings</span> (..))
<span class="kw">import </span><span class="dt">Network.Socket</span>(withSocketsDo)
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">B</span>

<span class="ot">fetchTestIssue ::</span> <span class="dt">IO</span> ()
fetchTestIssue <span class="fu">=</span> <span class="kw">do</span>
        <span class="co">-- We use a demo instance of Jira available on the web</span>
   <span class="kw">let</span>  _host <span class="fu">=</span>  <span class="st">&quot;https://jira.atlassian.com&quot;</span>
        <span class="co">-- We use the latest version of REST API to select one of the issues</span>
        <span class="co">-- and we limit the returned fields to be the summary and description only</span>
        uri  <span class="fu">=</span> _host <span class="fu">++</span> <span class="st">&quot;/rest/api/latest/issue/DEMO-3083?fields=summary,description&quot;</span>
        <span class="co">-- This is just to ignore the failure of the security certificate</span>
        settings <span class="fu">=</span> mkManagerSettings (<span class="dt">TLSSettingsSimple</span> <span class="dt">True</span> <span class="dt">False</span> <span class="dt">False</span>) <span class="dt">Nothing</span> 
   <span class="co">-- We make the request by parsing the URL, the request method by default is get</span>
   request  <span class="ot">&lt;-</span> parseUrl uri
   <span class="co">-- We do the request and receive the response</span>
   response <span class="ot">&lt;-</span> withSocketsDo <span class="fu">$</span> withManagerSettings settings <span class="fu">$</span> httpLbs request
        <span class="co">-- We select some of the headers of the response</span>
   <span class="kw">let</span>  hdr <span class="fu">=</span> filter g <span class="fu">.</span> responseHeaders <span class="fu">$</span> response
        g (h, _) <span class="fu">|</span> h <span class="fu">==</span> hContentType <span class="fu">=</span> <span class="dt">True</span>
        g (h, _) <span class="fu">|</span> h <span class="fu">==</span> hServer      <span class="fu">=</span> <span class="dt">True</span>
        g _                          <span class="fu">=</span> <span class="dt">False</span>
        <span class="co">-- We get the response body</span>
        bdy <span class="fu">=</span> responseBody response
   <span class="co">-- print the selected headers and response body</span>
   putStrLn <span class="fu">$</span> <span class="st">&quot;Response headers = \n&quot;</span> <span class="fu">++</span> show hdr
   putStrLn <span class="st">&quot;Response body = &quot;</span>
   B.putStrLn bdy </code></pre>
</section><section id="http-conduit-example-response" class="slide level2">
<h1>HTTP-Conduit example response</h1>
<pre class="stretch"><code>Response headers = 
[(&quot;Server&quot;,&quot;nginx&quot;),(&quot;Content-Type&quot;,&quot;application/json;charset=UTF-8&quot;)]
Response body = 
{&quot;expand&quot;:&quot;renderedFields,names,schema,transitions,operations,editmeta,changelog&quot;,
&quot;id&quot;:&quot;333132&quot;,
&quot;self&quot;:&quot;https://jira.atlassian.com/rest/api/latest/issue/333132&quot;,
&quot;key&quot;:&quot;DEMO-3083&quot;,
&quot;fields&quot;:{&quot;summary&quot;:&quot;Backspace to delete zero to enter your dosage &quot;,
&quot;description&quot;:&quot;You have to delete zero first before you can put in your Dosage&quot;}}</code></pre>
</section><section id="http-conduit" class="slide level2">
<h1>HTTP-Conduit</h1>
<ul>
<li>Has good documentation and examples</li>
<li>Really easy to use</li>
<li>Basically build URIs to Jira resources and fetch</li>
<li>Response is JSON</li>
<li>No need to manually parse JSON just use Aeson</li>
</ul>
</section><section id="aeson" class="slide level2">
<h1>Aeson</h1>
<ul>
<li>Aeson was the farther of Jason in Greek mythology</li>
<li>Aeson is the big daddy of JSON parsing</li>
<li>Encode and decode Haskell types to and from JSON</li>
<li>Added bonus you get YAML support</li>
<li>Have to define <code>FromJSON</code> and <code>ToJSON</code> instances for your type.
<ul>
<li>Automatic with <code>DeriveGeneric</code> GHC extension</li>
</ul></li>
<li>If JSON response doesn’t match type then manually define
<ul>
<li>Still very little overhead</li>
<li>Few parser combinators</li>
<li>Trick, wrap desired type in <code>newtype</code></li>
</ul></li>
<li>Example:
<ul>
<li>Decode response from Jira</li>
<li>Encode it as YAML</li>
<li>Print it out</li>
</ul></li>
</ul>
</section><section id="aeson-example" class="slide level2">
<h1>Aeson example</h1>
<pre class="sourceCode stretch Haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings, DeriveGeneric #-}</span>
<span class="kw">import           </span><span class="dt">Network.HTTP.Conduit</span>
<span class="kw">import           </span><span class="dt">Network.Connection</span> (<span class="dt">TLSSettings</span> (..))
<span class="kw">import           </span><span class="dt">Network.Socket</span>(withSocketsDo)
<span class="kw">import           </span><span class="dt">Control.Applicative</span>
<span class="kw">import qualified</span> <span class="dt">Data.Aeson</span> <span class="kw">as</span> <span class="dt">AS</span>
<span class="kw">import           </span><span class="dt">Data.Aeson</span> ((.:), (.:?), (.!=))
<span class="kw">import qualified</span> <span class="dt">Data.Aeson.Types</span> <span class="kw">as</span> <span class="dt">AS</span> (typeMismatch)
<span class="kw">import qualified</span> <span class="dt">Data.Yaml</span> <span class="kw">as</span> <span class="dt">YAML</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">B</span>
<span class="kw">import           </span><span class="dt">GHC.Generics</span>


<span class="co">-- The data type that will represent our issue</span>
<span class="kw">data</span> <span class="dt">Issue</span> <span class="fu">=</span> <span class="dt">Issue</span> {<span class="ot">issueId ::</span> <span class="dt">Int</span>, issueKey, issueSummary,<span class="ot"> issueDescription ::</span> <span class="dt">String</span>} 
             <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Generic</span>)
<span class="co">-- Automatically derive instances for our issue type allowing is to encode/decode</span>
<span class="co">-- to and from JSON and YAML. </span>
<span class="kw">instance</span> <span class="dt">AS.ToJSON</span> <span class="dt">Issue</span> 
<span class="kw">instance</span> <span class="dt">AS.FromJSON</span> <span class="dt">Issue</span> 

<span class="co">-- The newtype wrapper used to decode the JSON response body received</span>
<span class="co">-- from the Jira server</span>
<span class="kw">newtype</span> <span class="dt">IssueResponse</span> <span class="fu">=</span> <span class="dt">IssueResponse</span> {<span class="ot">issueFromResponse ::</span> <span class="dt">Issue</span>}

<span class="co">-- Manually define how to turn a JSON representation into a IssueResponse</span>
<span class="kw">instance</span> <span class="dt">AS.FromJSON</span> <span class="dt">IssueResponse</span> <span class="kw">where</span>
    parseJSON (<span class="dt">AS.Object</span> v) <span class="fu">=</span> <span class="kw">do</span>                <span class="co">-- v is the parsed JSON object</span>
        fields <span class="ot">&lt;-</span> v <span class="fu">.:</span> <span class="st">&quot;fields&quot;</span>                 <span class="co">-- select the fields member</span>
        <span class="co">-- Lift the Issue constructor into the parsing monad and</span>
        <span class="co">-- apply it to the results of looking up values in the JSON object</span>
        <span class="dt">Issue</span> <span class="fu">&lt;$&gt;</span> (read <span class="fu">&lt;$&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;id&quot;</span>)          <span class="co">-- select id member as an Int</span>
              <span class="fu">&lt;*&gt;</span> v <span class="fu">.:</span> <span class="st">&quot;key&quot;</span>                    <span class="co">-- select key member</span>
              <span class="fu">&lt;*&gt;</span> fields <span class="fu">.:</span> <span class="st">&quot;summary&quot;</span>           <span class="co">-- select summary from the fields</span>
              <span class="fu">&lt;*&gt;</span> fields <span class="fu">.:?</span> <span class="st">&quot;description&quot;</span>      <span class="co">-- optionally select description</span>
                                                <span class="co">-- from the fields.</span>
                         <span class="fu">.!=</span> <span class="st">&quot;No description&quot;</span>   <span class="co">-- if it is not present then this</span>
                                                <span class="co">-- will be the default value</span>
        <span class="co">-- Wrap the result type in IssueResponse</span>
        <span class="fu">&gt;&gt;=</span> pure <span class="fu">.</span> <span class="dt">IssueResponse</span>                
    <span class="co">-- Error message on parse failure</span>
    parseJSON a <span class="fu">=</span> AS.typeMismatch <span class="st">&quot;Expecting JSON object for Issue&quot;</span> a</code></pre>
</section><section id="aeson-example-1" class="slide level2">
<h1>Aeson example</h1>
<pre class="sourceCode stretch Haskell"><code class="sourceCode haskell"><span class="ot">fetchTestIssue ::</span> <span class="dt">IO</span> ()
fetchTestIssue <span class="fu">=</span> <span class="kw">do</span>
        <span class="co">-- We use a demo instance of Jira available on the web</span>
   <span class="kw">let</span>  _host <span class="fu">=</span>  <span class="st">&quot;https://jira.atlassian.com&quot;</span>
        <span class="co">-- We use the latest version of REST API to select one of the issues</span>
        <span class="co">-- and we limit the returned fields to be the summary and description only</span>
        uri  <span class="fu">=</span> _host <span class="fu">++</span> <span class="st">&quot;/rest/api/latest/issue/DEMO-3083?fields=summary,description&quot;</span>
        <span class="co">-- This is just to ignore the failure of the security certificate</span>
        settings <span class="fu">=</span> mkManagerSettings (<span class="dt">TLSSettingsSimple</span> <span class="dt">True</span> <span class="dt">False</span> <span class="dt">False</span>) <span class="dt">Nothing</span> 
   <span class="co">-- We make the request by parsing the URL</span>
   request  <span class="ot">&lt;-</span> parseUrl uri
   <span class="co">-- do the request</span>
   response <span class="ot">&lt;-</span> withSocketsDo <span class="fu">$</span> withManagerSettings settings <span class="fu">$</span> httpLbs request
   <span class="co">-- Get the response body. </span>
   <span class="co">-- Decode it as IssueResponse type possibly failing</span>
   <span class="co">-- If decoding was successful turn the result into an Issue type</span>
   <span class="co">-- Encode the whole result (possibly failed) as YAML</span>
   <span class="co">-- Print the resultant ByteString to the console </span>
   B.putStrLn <span class="fu">.</span> YAML.encode <span class="fu">.</span> fmap issueFromResponse <span class="fu">.</span> AS.decode <span class="fu">.</span> responseBody <span class="fu">$</span> response</code></pre>
</section><section id="aeson-example-output" class="slide level2">
<h1>Aeson example output</h1>
<pre class="sourceCode stretch YAML"><code class="sourceCode yaml"><span class="fu">issueDescription:</span> You have to delete zero first before you can put in your Dosage
<span class="fu">issueId:</span> 333132
<span class="fu">issueKey:</span> DEMO-3083
<span class="fu">issueSummary:</span> ! 'Backspace to delete zero to enter your dosage '</code></pre>
</section></section>
<section><section id="creating-the-document" class="titleslide slide level1"><h1>Creating the document</h1></section><section id="pandoc" class="slide level2">
<h1>Pandoc</h1>
<ul>
<li>Haskell library and command line utility</li>
<li>Read several markup formats
<ul>
<li>Markdown, reStructuredText, Textile, HTML, DocBook, LaTeX, MediaWiki markup, OPML, Emacs Org-Mode, Haddock markup</li>
</ul></li>
<li>Write several markup / document formats
<ul>
<li>HTML (XHTML, HTML5), HTML Slides (Slidy, reveal.js, Slideous, S5, DZSlides), Microsoft Word docx, OpenOffice/LibreOffice ODT, OpenDocument XML, EPUB, FictionBook2, DocBook, GNU TexInfo, Groff man pages, Haddock markup, InDesign ICML, OPML, LaTeX, ConTeXt,<br /> LaTeX Beamer Slides, PDF, Markdown, reStructuredText, AsciiDoc, MediaWiki markup, Emacs Org-Mode, Textile</li>
</ul></li>
<li>Modular
<ul>
<li>All readers parse to same AST</li>
<li>All writers consume same AST</li>
</ul></li>
<li>The AST is ideal for programmatically generating documents.</li>
<li>Example programmatically generate doc
<ul>
<li>Write out as Pandoc Markdown</li>
<li>Write out as HTML</li>
</ul></li>
</ul>
</section><section id="pandoc-example" class="slide level2">
<h1>Pandoc example</h1>
<pre class="sourceCode stretch Haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Text.Pandoc</span>
<span class="kw">import </span><span class="dt">Text.Pandoc.Builder</span> <span class="kw">hiding</span> (space)
<span class="kw">import </span><span class="dt">Text.Blaze.Renderer.String</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>


<span class="co">-- We use the helpers to construct an AST for a table with some text in it</span>
<span class="ot">aTable ::</span> [<span class="dt">Block</span>]
aTable <span class="fu">=</span> toList <span class="fu">$</span> <span class="co">-- convert the builder type to the AST type</span>
            <span class="co">-- Create a 2 column table without a caption a aligned left</span>
            table (str <span class="st">&quot;&quot;</span>) (replicate <span class="dv">2</span> (<span class="dt">AlignLeft</span>,<span class="dv">0</span>)) 
                <span class="co">-- The header row for the table</span>
                [ para <span class="fu">.</span> str <span class="fu">$</span> <span class="st">&quot;Gordon&quot;</span>, para <span class="fu">.</span> str <span class="fu">$</span> <span class="st">&quot;Ramsy&quot;</span>]
                <span class="co">-- The rows of the table</span>
                [ [para <span class="fu">.</span> str <span class="fu">$</span> <span class="st">&quot;Sally&quot;</span>, para <span class="fu">.</span> str <span class="fu">$</span> <span class="st">&quot;Storm&quot;</span>]
                , [para <span class="fu">.</span> str <span class="fu">$</span> <span class="st">&quot;Blah&quot;</span>,  para <span class="fu">.</span> str <span class="fu">$</span> <span class="st">&quot;Bleh&quot;</span>]
                ]

<span class="co">-- Create our document along with its meta data</span>
<span class="ot">myDoc ::</span> <span class="dt">Pandoc</span>
myDoc <span class="fu">=</span> <span class="dt">Pandoc</span> (<span class="dt">Meta</span> M.empty) aTable

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- render as Pandoc Markdown</span>
    putStrLn <span class="fu">$</span> writeMarkdown def myDoc
    <span class="co">-- render as HTML</span>
    putStrLn <span class="fu">$</span> renderMarkup <span class="fu">$</span> writeHtml def myDoc</code></pre>
</section><section id="pandoc-example-output" class="slide level2">
<h1>Pandoc example output</h1>
<pre class="stretch"><code>  Gordon   Ramsy
  -------- -------
  Sally    Storm
  Blah     Bleh

  :


&lt;table&gt;
&lt;caption&gt;&lt;/caption&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th align=&quot;left&quot;&gt;&lt;p&gt;Gordon&lt;/p&gt;&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;&lt;p&gt;Ramsy&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td align=&quot;left&quot;&gt;&lt;p&gt;Sally&lt;/p&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;p&gt;Storm&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td align=&quot;left&quot;&gt;&lt;p&gt;Blah&lt;/p&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;p&gt;Bleh&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;</code></pre>
</section><section id="parsing-jira-markup-with-parsec" class="slide level2">
<h1>Parsing Jira markup with Parsec</h1>
<ul>
<li>Issue description formatted as Jira markup</li>
<li>Preserve formatting in generated document</li>
<li>No Pandoc reader for Jira Markup</li>
<li>Haskell is good at parsing use Parsec
<ul>
<li>Monadic parser combinator library</li>
<li>Parse context-sensitive, infinite look-ahead grammars</li>
<li>Performs best on predictive (LL[1]) grammars</li>
</ul></li>
<li>Example using parsec to transform some text</li>
</ul>
</section><section id="parsec-example" class="slide level2">
<h1>Parsec example</h1>
<pre class="sourceCode stretch Haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Text.Parsec.Char</span>
<span class="kw">import           </span><span class="dt">Text.Parsec.String</span> (<span class="dt">Parser</span>)
<span class="kw">import           </span><span class="dt">Text.Parsec.Prim</span> <span class="kw">hiding</span> ((&lt;|&gt;))
<span class="kw">import           </span><span class="dt">Text.Parsec.Combinator</span>
<span class="kw">import           </span><span class="dt">Control.Applicative</span>
<span class="kw">import           </span><span class="dt">Control.Monad</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import           </span><span class="dt">Data.Maybe</span>

<span class="co">-- Parse an issue description and replace the issue references</span>
<span class="ot">replaceIssueRefs ::</span> <span class="dt">M.Map</span> <span class="dt">String</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
                     <span class="co">-- multiple times parse either a link or normal text</span>
                     <span class="co">-- and then concatenate it all into a single string</span>
replaceIssueRefs m <span class="fu">=</span> concat <span class="fu">&lt;$&gt;</span> (many1 <span class="fu">.</span> choice <span class="fu">$</span> [issue_ref, normal_text])
    <span class="kw">where</span>
        <span class="co">-- normal text is any character until we reach an issue reference or end of file</span>
        normal_text <span class="fu">=</span> manyTill anyChar (lookAhead (void issue_ref <span class="fu">&lt;|&gt;</span> eof)) 
                      <span class="co">-- check that this parse does not except empty text</span>
                      <span class="fu">&gt;&gt;=</span> \txt' <span class="ot">-&gt;</span> <span class="kw">if</span> null txt' <span class="kw">then</span> fail <span class="st">&quot;&quot;</span> <span class="kw">else</span> return txt'
        <span class="co">-- match the string DEMO- followed by at least 1 digit</span>
        <span class="co">-- lookup the matched string in the map replacing it</span>
        <span class="co">-- if the parser fails consume no input</span>
        issue_ref <span class="fu">=</span> try <span class="fu">$</span> fromJust <span class="fu">.</span> (<span class="ot">`M.lookup`</span> m) <span class="fu">&lt;$&gt;</span> ((<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> string <span class="st">&quot;DEMO-&quot;</span> <span class="fu">&lt;*&gt;</span> many1 digit)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
        <span class="co">-- The map of issue references to replace</span>
    <span class="kw">let</span> m <span class="fu">=</span> M.fromList [(<span class="st">&quot;DEMO-132&quot;</span>, <span class="st">&quot;OMED-457&quot;</span>), (<span class="st">&quot;DEMO-987&quot;</span>, <span class="st">&quot;OMED-765&quot;</span>)]
        <span class="co">-- The input issue description text</span>
        s <span class="fu">=</span> <span class="st">&quot;See issue DEMO-132 for more information related the bug listed in DEMO-987&quot;</span>
    <span class="co">-- parse the issue description using the replaceIssueRefs parser</span>
    <span class="kw">case</span> parse (replaceIssueRefs m) <span class="st">&quot;&quot;</span> s <span class="kw">of</span>               
                        <span class="dt">Left</span> e <span class="ot">-&gt;</span> print e       <span class="co">-- on failure print error</span>
                        <span class="dt">Right</span> rs <span class="ot">-&gt;</span> putStrLn rs <span class="co">-- on success print out:</span>
    <span class="co">-- See issue OMED-457 for more information related the bug listed in OMED-765</span></code></pre>
</section></section>
<section><section id="my-experience" class="titleslide slide level1"><h1>My experience</h1></section><section id="overview-of-experience" class="slide level2">
<h1>Overview of experience</h1>
<ul>
<li>A lot of Haskell code is declarative
<ul>
<li>Can get far just gluing things together</li>
<li>Type system guides the gluing</li>
<li>No need to solve anything functionally</li>
</ul></li>
<li>Eventually had to solve functionally
<ul>
<li>Early hurdle due to imperative background</li>
<li>Difficult to explore flawed thinking (where is my <code>printf</code> and debugger)</li>
<li>Maybe <code>Debug.Trace</code> ? No still difficult. Lazy and declarative.</li>
<li>Runtime failures not very helpful</li>
</ul></li>
<li>At least Haskell is very consistent
<ul>
<li>A few idioms and operators to learn</li>
<li>Used the same everywhere and you know what to expect</li>
<li>Libraries seem convergent</li>
</ul></li>
<li>Most libraries are very composable</li>
<li>Code is succinct</li>
<li>Type system gives you confidence
<ul>
<li>No you can’t do that because you are an idiot</li>
</ul></li>
</ul>
</section><section id="error-reporting" class="slide level2">
<h1>Error reporting</h1>
<ul>
<li>I like the idea of let it break</li>
<li>Problem in Haskell; no stack trace</li>
<li>Actually a difficult problem in Haskell
<ul>
<li>Semantic stack and execution stack not usually the same</li>
<li>Code is Lazy</li>
<li>Code is higher order</li>
<li>Code gets optimized (i.e. reorganized)</li>
</ul></li>
<li>There are somethings you can do
<ul>
<li>Recompile with profiling (won’t help in rare production crash)</li>
<li>See Simon Marlow’s talk <a href="http://www.youtube.com/watch?v=J0c4L-AURDQ">HIW 2012. Simon Marlow: Why can’t I get a stack trace</a></li>
</ul></li>
<li>Probably better to explicitly handle failure.</li>
</ul>
</section><section id="printf-with-debug.trace" class="slide level2">
<h1>Printf with Debug.Trace</h1>
<ul>
<li><code>Debug.Trace</code> is a <code>printf</code> escape hatch for pure code</li>
<li>Only emits when statement is evaluated</li>
<li>Since Haskell is lazy, often never emits</li>
<li>Trying to debug the parser was a pain
<ul>
<li>Probably should have written it better</li>
</ul></li>
<li>Hacked my parser to force evaluation
<ul>
<li>Allowed me to see what was happening in Parsec</li>
<li>Helped me understand all my misconceptions</li>
</ul></li>
</ul>
<pre class="sourceCode stretch Haskell"><code class="sourceCode haskell"><span class="co">-- ......</span>
<span class="kw">type</span> <span class="dt">MyParser</span> <span class="fu">=</span> <span class="dt">Parsec</span> <span class="dt">String</span> <span class="dt">ParseState</span>
<span class="co">-- .....</span>
<span class="co">-- Really gross but worked.</span>
<span class="co">-- Force trace to emit by requiring subsequent parser actions</span>
<span class="co">-- to access the parse state through my trace message</span>
<span class="ot">traceM' ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MyParser</span> ()
traceM' msg <span class="fu">=</span> getState <span class="fu">&gt;&gt;=</span> (\s <span class="ot">-&gt;</span> return <span class="fu">$!</span> trace (<span class="ch">'\n'</span> <span class="fu">:</span> msg) s) <span class="fu">&gt;&gt;=</span> setState</code></pre>
</section></section>
<section><section id="wrapping-up" class="titleslide slide level1"><h1>Wrapping up</h1></section><section id="the-tool" class="slide level2">
<h1>The tool</h1>
<ul>
<li>The tool can be found here <a href="https://github.com/HanStolpo/JiraStructureToDocx">https://github.com/HanStolpo/JiraStructureToDocx</a></li>
<li>Quality of code is low (just good enough for us to use internally)</li>
<li>The same goes for the non existent documentation</li>
</ul>
</section><section id="some-links" class="slide level2">
<h1>Some Links</h1>
<ul>
<li>Jira: <a href="https://www.atlassian.com/software/jira">https://www.atlassian.com/software/jira</a></li>
<li>Pandoc: <a href="http://johnmacfarlane.net/pandoc/">http://johnmacfarlane.net/pandoc/</a></li>
<li>http-conduit: <a href="https://hackage.haskell.org/package/http-conduit">https://hackage.haskell.org/package/http-conduit</a></li>
<li>Real World Haskell: <a href="http://book.realworldhaskell.org/">http://book.realworldhaskell.org/</a></li>
<li>Learn You a Haskell for Great Good!: <a href="http://learnyouahaskell.com/">http://learnyouahaskell.com/</a></li>
<li>Parsec: <a href="http://hackage.haskell.org/package/parsec">http://hackage.haskell.org/package/parsec</a></li>
<li>Jira markup: <a href="https://jira.atlassian.com/secure/WikiRendererHelpAction.jspa?section=all">https://jira.atlassian.com/secure/WikiRendererHelpAction.jspa?section=all</a></li>
<li>Structure: <a href="http://almworks.com/structure/overview.html">http://almworks.com/structure/overview.html</a></li>
<li>Pandoc AST: <a href="http://hackage.haskell.org/package/pandoc-types-1.12.3.3/docs/Text-Pandoc-Definition.html">http://hackage.haskell.org/package/pandoc-types-1.12.3.3/docs/Text-Pandoc-Definition.html</a></li>
<li>Jira REST API: <a href="https://developer.atlassian.com/display/JIRADEV/JIRA+REST+APIs">https://developer.atlassian.com/display/JIRADEV/JIRA+REST+APIs</a></li>
<li>Roy Fielding: <a href="http://en.wikipedia.org/wiki/Roy_Fielding">http://en.wikipedia.org/wiki/Roy_Fielding</a></li>
<li>REST_Thesis: <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a></li>
<li>REST APIs must be hypertext-driven: <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a></li>
<li>What exactly is RESTful programming?: <a href="http://stackoverflow.com/questions/671118/what-exactly-is-restful-programming">http://stackoverflow.com/questions/671118/what-exactly-is-restful-programming</a></li>
<li>REST applied to web services: <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer#Applied_to_web_services">http://en.wikipedia.org/wiki/Representational_State_Transfer#Applied_to_web_services</a></li>
<li>REST constraints: <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer#Architectural_constraints">http://en.wikipedia.org/wiki/Representational_State_Transfer#Architectural_constraints</a></li>
<li>aeson: <a href="http://hackage.haskell.org/package/aeson">http://hackage.haskell.org/package/aeson</a></li>
<li>YAML: <a href="http://hackage.haskell.org/package/yaml-0.8.8.2">http://hackage.haskell.org/package/yaml-0.8.8.2</a></li>
</ul>
</section></section>
<section><section id="end" class="titleslide slide level1"><h1>END</h1></section></section>
			</div>
		</div>

		<script src="../lib/js/head.min.js"></script>
		<script src="../js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'convex', // none/fade/slide/convex/concave/zoom
				// The "normal" size of the presentation, aspect ratio will be preserved
				// when the presentation is scaled to fit different resolutions. Can be
				// specified using percentage units.
				// width: 1160,
				// height: 720,
				width: 1920,
				height: 1080,
				// Factor of the display size that should remain empty around the content
				margin: 0.01,

				// Bounds for smallest/largest possible scale to apply to content
				minScale: 0.05,
				maxScale: 1.5,

				// Optional reveal.js plugins
				dependencies: [
					{ src: '../lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
